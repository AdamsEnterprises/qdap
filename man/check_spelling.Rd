% Generated by roxygen2 (4.0.1): do not edit by hand
\name{check_spelling}
\alias{check_spelling}
\alias{which_misspelled}
\title{Check Spelling}
\usage{
check_spelling(text.var, range = 2, max.distance = 0.05,
  assume.first.correct = TRUE,
  dictionary = qdapDictionaries::GradyAugmented, parallel = TRUE,
  cores = parallel::detectCores()/2)

which_misspelled(x, suggest = FALSE, range = 2, max.distance = 0.05,
  assume.first.correct = TRUE,
  dictionary = qdapDictionaries::GradyAugmented,
  nchar.dictionary = nchar(dictionary),
  first.char.dictionary = substring(dictionary, 1, 1))
}
\arguments{
\item{text.var}{The text variable.}

\item{range}{An integer of length 1 to use as a range for number of
characters, beyond the number of characters of a word not found in the
\code{dictionary}, to initially limit \code{dictionary} size and thus time to
find a suggested replacement term.  This may be expanded if no suitable
suggestion is returned.}

\item{max.distance}{A maximum distance to use as a starting \code{dictionary}
reduction as the \code{max.distance} passed to \code{\link[base]{agrep}}.
This may be increased if no suitable suggestion is returned.}

\item{assume.first.correct}{logical.  If \code{TRUE} it is assumed that the
first letter of the misspelled word is correct.  This reduces the dictionary
size, thus speeding up computation.}

\item{dictionary}{A character vector of terms to search for.  To reduce
overhead it is expected that this dictionary is lower case, unique terms.}

\item{parallel}{logical.  If \code{TRUE} attempts to run the function on
multiple cores.  Note that this may not mean a speed boost if you have one
core or if the data set is smaller as the cluster takes time to create.}

\item{cores}{The number of cores to use if \code{parallel = TRUE}.  Default
is half the number of available cores.}

\item{x}{A character string.}

\item{suggest}{logical.  If \code{TRUE} returns a
\code{\link[base]{data.frame}} with possible suggestions for misspelled words
(words not found in the dictionary).}
}
\value{
\code{check_spelling} - Returns a \code{\link[base]{data.frame}} with
\code{row} (row number), \code{not.found}  \code{word.no} (number of
misspelled word), \code{not.found} (a word not found in the dictionary),
\code{suggestion} (the most likely replacement for the word), and
\code{more.suggestions} (A list of vectors of up to 10 most likely replacements).

\code{which_misspelled} - Returns either a named vector (names are
the word number) of possible misspelled words (if\code{suggestions = FALSE})
or a \code{\link[base]{data.frame}} with \code{word.no} (number of misspelled
word), \code{not.found} (a word not found in the dictionary),
\code{suggestion} (the most likely replacement for the word), and
\code{more.suggestions} (A list of vectors of up to 10 most likely replacements).
}
\description{
\code{check_spelling} - Check the spelling for an vector of strings.  The
function use the following technique:\cr
\itemize{
  \item Separate the words from a string into a bag of words.
  \item Look those words up in a dictionary to find words not recognized/found (considered possibly misspelled).
  \item These misses (possible misspellings) will be what is looked up for suggested replacements.
  \item Optionally, reduce dictionary by assuming the first letter of the misspelled word is correct (dictionary for this letter only).
  \item Reduce dictionary by eliminating words outside of the range of number of characters of the misspelled word.
  \item Reduce dictionary further by eliminating words with \code{\link[base]{agrep}} to within a preset tolerance (\code{max.distance}).
  \item Use a binary lookup (that reverse engineers \code{\link[base]{agrep}}) to determine the word from dictionary that is closest to the misspelled term.
}

\code{which_misspelled}  - Check the spelling for a string.
}
\note{
A possible misspelled word is defined as not found in the
\code{dictionary}.  Currently, the \code{dictionary} used is smaller and may
not contain words with endings.  This may lead to false positives for
misspelled words.
}
\examples{
\dontrun{
x <- "Robots are evl creatres and deserv exterimanitation."
which_misspelled(x, suggest=FALSE)
which_misspelled(x, suggest=TRUE)

check_spelling(DATA$state)
check_spelling(DATA$state, stem=FALSE)

## browseURL("http://stackoverflow.com/a/24454727/1000343")
terms <- c("accounts", "account", "accounting", "acounting", "acount", "acounts", "accounnt")

set.seed(10)
(fake_text <- unlist(lapply(terms, function(x) {
    unbag(sample(c(x, sample(DICTIONARY[[1]], sample(1:5, 1)))))
})))

check_spelling(fake_text)
}
}
\references{
\url{http://stackoverflow.com/a/24454727/1000343}
}

